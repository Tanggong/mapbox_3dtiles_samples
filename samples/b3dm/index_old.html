<html>
    <head>
        <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.js'></script>
        <script src='../../libs/three.min.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.9.0/mapbox-gl.css' rel='stylesheet' />
        <script src="../../libs/GLTFLoader.js"></script>
        <script src="../../libs/Mapbox3DTiles.js"></script>
        <style>
            body { margin:0; padding:0; }
            #map { position:absolute; top:0; bottom:0; width:100%; }
            .container {
                position: absolute;
                left: 5px;
                padding: 5px;
                border: 1px solid gray;
                border-radius: 2px;
                background-color: black;
                color: white;
                min-width: 200px;
            }
            
            #controls { position:absolute; top:0; left:0; }
            #info { 
			    top:75px; 
			    min-height: 75px;
		    }
        </style>
    </head>
    <body>
            <div id='map'></div>
            <div id="info" class="container"></div>

            <script>
            mapboxgl.accessToken = 'pk.eyJ1IjoiYmVydHQiLCJhIjoiaWFvN1Z4USJ9.k04Q6CVms4Gx7KDZxvAx2A';

            var map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v11',
                center: [ 5.598922, 51.462921],
                zoom: 17.94,
                bearing: 0,
                pitch: 51,
                hash: true
            });

             map.on('style.load', function() {
                map.addLayer(woonconnect1Layer);

                // let tileslayer = new Mapbox3DTiles.Layer( { 
                //     id: 'delaware', 
                //     url: 'tileset.json'
                // } );
                // map.addLayer(tileslayer, 'waterway-label');
            });
            map.on('mousemove', (event)=>{
                let infoElement = document.querySelector('#info');
                let features = map.queryRenderedFeatures(event.point, {outline: true, outlineColor: 0xff0000});
                if (features.length) {
                    infoElement.innerHTML = 
                        features.map(feature=>
                            `Layer: ${feature.layer.id}<br>
                                ${Object.entries(feature.properties).map(entry=>`<b>${entry[0]}:</b>${entry[1]}`).join('<br>\n')}
                        `).join('<hr>\n')
                } else {
                    infoElement.innerHTML = "Hover map objects for info";
                }
            })


            // parameters to ensure the model is georeferenced correctly on the map
            var modelOrigin_W1 = [5.5981999,51.4629160];
            var modelAltitude_W1 = 0;
            var modelRotate_W1 = [Math.PI / 2, Math.PI*-0.005, 0];

            var modelAsMercatorCoordinate_W1 = mapboxgl.MercatorCoordinate.fromLngLat(
                modelOrigin_W1,
                modelAltitude_W1
            );

            // transformation parameters to position, rotate and scale the 3D model onto the map
            var modelTransform_W1 = {
                translateX_W1: modelAsMercatorCoordinate_W1.x,
                translateY_W1: modelAsMercatorCoordinate_W1.y,
                translateZ_W1: modelAsMercatorCoordinate_W1.z,
                rotateX_W1: modelRotate_W1[0],
                rotateY_W1: modelRotate_W1[1],
                rotateZ_W1: modelRotate_W1[2],
                /* Since our 3D model is in real world meters, a scale transform needs to be
                    * applied since the CustomLayerInterface expects units in MercatorCoordinates.
                    */
                scale_W1: modelAsMercatorCoordinate_W1.meterInMercatorCoordinateUnits()
            };

            var THREE = window.THREE;

            var woonconnect1Layer = {
                id: 'Woonconnect 1',
                type: 'custom',
                renderingMode: '3d',
                onAdd: function(map, gl) {
                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();

                    var lightm = new THREE.HemisphereLight( 0xffffff, 0x080820, 0.75);
                    this.scene.add( lightm );
                    var loader = new THREE.GLTFLoader();
                    loader.load(
                        'Woonconnect_1_2020_6_17.glb',
                        function(gltf) {
                            this.scene.add(gltf.scene);
                        }.bind(this)
                    );
                    this.map = map;
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true
                    });

                    this.renderer.autoClear = false;
                },
                render: function(gl, matrix) {
                    var rotationX_W1 = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(1, 0, 0),
                        modelTransform_W1.rotateX_W1
                    );
                    var rotationY_W1 = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 1, 0),
                        modelTransform_W1.rotateY_W1
                    );
                    var rotationZ_W1 = new THREE.Matrix4().makeRotationAxis(
                        new THREE.Vector3(0, 0, 1),
                        modelTransform_W1.rotateZ_W1
                    );

                    var m = new THREE.Matrix4().fromArray(matrix);
                    var l = new THREE.Matrix4()
                        .makeTranslation(
                            modelTransform_W1.translateX_W1,
                            modelTransform_W1.translateY_W1,
                            modelTransform_W1.translateZ_W1
                        )
                        .scale(
                            new THREE.Vector3(
                                modelTransform_W1.scale_W1,
                                -modelTransform_W1.scale_W1,
                                modelTransform_W1.scale_W1
                            )
                        )
                        .multiply(rotationX_W1)
                        .multiply(rotationY_W1)
                        .multiply(rotationZ_W1);

                    this.camera.projectionMatrix = m.multiply(l);
                    this.renderer.state.reset();
                    this.renderer.render(this.scene, this.camera);
                    this.map.triggerRepaint();
                }

            };

            </script>
    </body>
</html>